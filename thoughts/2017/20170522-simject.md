# Simjects

2017-05-22 thoughts

What the heck is this?

A simject is a 'simulated object'.

Differentiate from an 'entity',
which has the connotation of that object having an identity
separate from its state.
Though entities can be modeled as simjects.

The point of defining this is that I'd like to unify the
interface for simulating different kinds of things.

## Naming of implementation classes

Say there's a simject class "http://ns.nuke24.net/Game21/Simject/Frubber"

There might be associated:
- An interface representing the state of a frubber
  - Having this be defined separately from behavior allows
    deserialization to be as simple as JSON.parse.
  - It also potentially makes any APIs to the simulator simpler,
    as data objects can be created with array literals and passed
    in directly without having to convert between internal/external form
  - I'm sort of attached to the idea
- A class that's responsible for simulating frubber behavior,
  but whose instances are not associated with any given Frubber
- A class that wraps a frubber and its behavior
  so you can treat it as a more traditional OO thing
  with state + behavior all wrapped together


How to name the 'frubber state' interface?
Some options:

1. Frubber (FrubberSimulator, FrubberShell)
  - pro: matches name in class reference
  - pro: consistent with e.g. Vector3D
  - con: need to come up with different name for combined data+behavior
2. FrubberState (FrubberSimulator, FrubberShell)
  - pro: explicit; purpose is obvious
  - pro: allows use of 'Frubber' as the state+behavior name
  - con: doesn't match name in class reference
  - con: doesn't match convention used by Vector3D, etc
3. Do away with the separate interface for the thing's state
  - note: lots of programs do this and are successful, e.g. Factorio
  - pro: don't have to come up with naming convention
  - con: need to write serialization and deserialization functions
  - con: 'user-friendly APIs' are much more complex since you can't pass state directly

3 sucks because I'm very attached to the work reduction that comes
with not having to write conversion code.

So 1 or 2, 1 or 2...bah, let's just keep doing what we're already doing.
Option 1 it is.


## So anyway

The point is to unify the interface to all simulated things,
and therefore to all the simulator classes.
Which might mean that there is a single SimjectSimulator interface
that defines all the different things that can be done to a Simject,
either by defining a bunch of different methods,
or by having a updateBasedOnEvent(any event goes here) method.

I'm leaning towards the separate methods.
With a base class that just does nothing, this won't be too bad.

Entities - simulated as simjects!
Entitity subsystems - also simulated as simjects!
The whole game - would be nice if this followed the same interface!


## Updates

Simjects behavior consists of:
- Doing things in response to
  - time passing
  - receiving a signal on a network port
  - being bumped into
  - receiving an item
  - anything else imaginable
- Indicating the next point in time at which it will do something lacking any other input

And 'doing things' could mean:
- Altering the state of the subject
- Destroying the subject
- Altering or destroying a _containing_ object
- Altering or destroying some not-directly-related object
- Sending a signal
- Imparting a force onto some other object
- Lots of other stuff

Implementation approaches:
1. Object has full access to the simulation and can modify things directly
  - pro: simple on the face of it
  - con: implies everything is mutable
  - con: harder to mock the environment of an object
  - con: may result in infinite recursion
  - note: Factorio pretty much does this, and it works
2. behavior method is passed an object that can be used to make changes
3. behavior method returns or appends to a list of actions to be done

Option 2 can be implemented in terms of option 3, and maybe insulates
behavior implementation a little bit from that of the simulator.

Okay let's do option 2.  Let's call that thing a SimjectSimulationContext.

Options for an object changing itself:
1. behavior method must use the same method to change the subject as it uses
   to affect other things in the world
  - pro: makes for a relatively consistent interface
  - pro: behavior doesn't have to worry about [im]mutability of object;
    the simulation implementation (separate from/external to the behavior)
    can have a single place that can make modifications
    - Something like this is already done by [Maze1]SimulationUpdate#mutateEntityAtPath
  - con: maybe a little slower?
  - con: harder to simulate 'procedural' logic within an update,
    where multiple changes are made in quick succession that depend on each other
  - con: when changing self
2. behavior method can return a new version of the thing its changing
  pro: maybe simplifies the 'changing itself' behavior code
  con: changing yourself is different than changing others
  con: you'll end up doing things 2 different ways
  con: the whole mutateEntityPath thing will be necessary anyway
3. combination of 2+3: changing anything is an action,
  but that action can indicate a mutation function that operates solely on
  one simject.

Option 3 it is.  Glad I got that sorted out.

```
abstract class SimjectSimulator<SC extends Simject> {
	getNextUpdateTime(subject:SC):Timestamp;
	timePassed(subject:SC, newTime:Timestamp, context:SimjectSimulationContext):void;
	respondToSomeOtherEvent(subject:SC, whateverEventInfo:blah, someotherarg:blah, context:SimjectSimulationContext):void;
}
```
