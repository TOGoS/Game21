class 'short string' : extends(string) : comment @ "Less than 128 chars, maybe?"
class 'scalar' : comment @ "A number, boolean, or short string."
class 'symbol' : extends(short string) : comment @ "A string that's meant to be used as an identifier."

#### Image data

class 'directional light' {
	color : RGB
	direction : 3D vector
}

class 'lighting environment' {
	directional lights : list(directional light)
	environment map : URN reference(RGB image)
}

class 'material' {
	# From outer to inner-most:
	
	mirror roughness : float
	mirror color : RGBA # A determines how much light is reflected vs passes to the next layer
	
	# behind the mirrored surface:
	gloss index of refraction : float # when 1.0, no gloss effect!
	
	# inside the glossy surface
	diffuse color : RGBA # when A < 1, some light passes through the back of the object
}

class 'material map' : extends(map(uint8, UUID reference(material)))
class 'material remap' : extends(map(uint8, unint8))

class 'shape sheet' {
	width : uint
	height : uint
	default material map : UUID reference(material map)
	cell material indexes : uint8[width*height]
	cell corner depth : float[width*height*4]
	
	# derived
	preview image : uint8[width*height*4]
}

class 'pixel rectangle' { # represented in JS by a 4-element array
	x : uint
	y : uint
	width : uint
	height : uint
}

class 'shape sheet shape' {
	shape sheet : UUID reference(shape sheet)
	bounds : pixel rectangle
}

class 'shape sheet slice' {
	shape sheet : shape sheet
	origin : 3D vector
	resolution : number : comment @ "pixels per meter"
	bounds : pixel rectangle
}

class 'object visual frame' {
	visual basis type @ ("shape sheet"|"procedural")
	material remap : material remap
	shape : (procedural shape | shape sheet slice) 
}

class 'animation' : type parameter @ "frame type" {
	speed : number : comment @ "frames per second"
	on end : ('stop'|'loop')
	frames : list(frame type)
}

class 'state applicability flag' : extends(symbol)

class 'object visual state' {
	shape sheet shape : UUID reference(shape sheet shape)
	# Map of flags to their preferred values;
	# the state with the most matching flags is the one used
	applicability flags : map(state applicability flag, scalar)
	
	animation : animation(frame type @ object visual frame)
}

class 'object visual' : comment @ unindent @ «
	An 'object visual' is a somewhat abstract notion of 'the way this thing looks'.
	A single visual can be used to visualize the same object in multiple states.
	e.g. a character walking might reference a single visual, but look
	slightly different in different positions and in different walking frames.
	Each 'state' is itself an animation with multiple frames,
	and a single animation frame may itself be an animated procedural shape
	that can render itself at multiple time points within that animation
	frame.
» {
	material map : UUID reference(material map)
	states : set(shape sheet object visual state)
}

#### World data

# I think the idea of using integers for room IDs was that related
# rooms would have similar integers, and in worlds being processed by
# multiple servers, interactions between rooms on different servers
# could be minimized that way.  but maybe that's dumb.
class 'room ID' : extends(integer)

class 'entity ID' : extends(UUID)

class 'physical object' {
	prototype : UUID reference(physical object) : nullable
	entity ID : entity ID : nullable
	visual : UUID reference(object visual)
	# ...and various physical properties...
}

class 'non-tile transform' {
	flip X : boolean
	rotation : float # In degrees so that 90° increments are whole numbers, not this radians crap
}

class 'non-tile' : extends(physical object) {
	prototype : UUID reference(physical object)
	transform : non-tile transform
	# ...potentially overrides of physical properties...
}

class 'tile transform' { # can be represented by an integer 0..7; i.e. 3 = 0b011 = don't flip, then rotate 270 degrees CW
	flip X : boolean              # bit 2
	rotation : enum(0,90,180,270) # bits 1 and 0
}

class 'tile' : extends(physical object) {
	transform : tile transform
	# ...potentially overrides of physical properties...
}

abstract class 'tile tree' {
	width  : integer
	height : integer
	depth  : integer
}

class 'tile stack' : comment @ "A bunch of tiles taking up the same space" {
	tiles : list(UUID reference(tile))
}

class 'tile tree leaf' : extends(tile tree) {
	# Probably compressed using a shared tile number => UUID list
	tile stacks : list(tile stack)
}

class 'tile tree branch' : extends(tile tree) {
	subtrees : list(tile tree)
}

class 'bounding cuboid' {
	minimum X : number
	minimum Y : number
	minimum Z : number
	maximum X : number
	maximum Y : number
	maximum Z : number
}

class 'room neighbor' : comment @ "Where's another room relative to this one?" {
	room : UUID reference(room)
	X : number
	Y : number
	Z : number
}

class 'room' {
	neighbors : list(room neighbor)
	bounds : bounding cuboid
	tile data : URN reference(tile tree)
	non-tiles : list(non-tile)
}

#### 

class 'game' {
	world : URN reference(world)
	shape sheets : URN reference map(UUID, shape sheet)
	shape sheet shapes : URN reference map(UUID, shape sheet shape)
	object visuals : URN reference map(UUID, object visual)
	rooms : URN reference map(room ID, room)
	lighting environment : URN reference(lighting environment)
}
